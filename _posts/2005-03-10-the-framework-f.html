---
layout: post
title: The Framework For Editing XML Document
published: true
category:
- software
---
<p><font color="#cc3333">Warning: This will get a bit technical for <em>some</em> of you.</font><br /><br />I was to post this yesterday night, but too tired and sleepy. Anyways.. I have yet to hear a convincing case against this design, so I'm soliciting for one here   if any. Let's say you'll need to do a Graphical Editor application allowing users to do some doodle drawing or whatever, and let them save their art as a file   an XML file. A few possible patterns comes to mind.. I'll list them in order of working furthest away from XML to the closest  working on XML directly.<br /><br /><strong>The Candidates</strong><br /><br />Method #1   Model Only<br /><br /><ol><li>Read XML from file, and <span style="FONT-WEIGHT: bold">instantiate a DOM</span> object.</li><li><span style="FONT-WEIGHT: bold">Parse the DOM</span>, look for specific elements (e.g. &lt;circle /&gt;, &lt;square /&gt;) and <span style="FONT-WEIGHT: bold">instantiate your corresponding objects</span> for them (e.g. new SquareObject, new CircleObject) and <span style="FONT-WEIGHT: bold">copy the values from XML to your object</span> (e.g. SquareObject.x = Square.getAttribute(&quot;x&quot;))</li><li>Parse until you finish all elements in your DOM, and you now have a handful of model objects in memory.</li><li><span style="FONT-WEIGHT: bold">Remove the DOM</span> from memory.</li><li>Now your Graphical Editor <span style="FONT-WEIGHT: bold">application manipulate your Model objects</span> based on the user s inputs.. Draw a line.. Paint as red.. etc</li><li>User choose to save, you <span style="FONT-WEIGHT: bold">get your Model objects to spit XML</span> back to you,</li><li>You piece together these XML fragments to <span style="FONT-WEIGHT: bold">create DOM</span> and <span style="FONT-WEIGHT: bold">save the DOM</span> as the file (overwrite the original file)<br /></li></ol></p>

<p><a href="http://www.flickr.com/photos/choonkeat/16182853/" title="Photo Sharing"><img src="http://photos11.flickr.com/16182853_f094b5fe5e_o.jpg" width="523" height="317" alt="760_method1" /></a></p>

<p><br /><br />Method #2   Model (Reuse DOM)<br /><br /><ol><li>Read XML from file, and <span style="FONT-WEIGHT: bold">instantiate a DOM</span> object. </li><li><span style="FONT-WEIGHT: bold">Parse the DOM</span>, look for specific elements (e.g. &lt;circle /&gt;, &lt;square /&gt;) and <span style="FONT-WEIGHT: bold">instantiate your corresponding objects</span> for them (e.g. new SquareObject, new CircleObject) and <span style="FONT-WEIGHT: bold">copy the values from XML to your object</span> (e.g. SquareObject.x = Square.getAttribute(&quot;x&quot;)) </li><li>Parse until you finish all elements in your DOM, and you now have a handful of model objects in memory. </li><li style="TEXT-DECORATION: line-through"><span style="FONT-WEIGHT: bold">Remove the DOM</span> from memory. </li><li>Now your Graphical Editor <span style="FONT-WEIGHT: bold">application manipulate your Model objects</span> based on the user s inputs.. Draw a line.. Paint as red.. etc </li><li>User choose to save, you <span style="FONT-WEIGHT: bold">get your Model objects to </span><span style="TEXT-DECORATION: line-through">spit XML</span><span style="TEXT-DECORATION: line-through"> back to you</span><span style="FONT-WEIGHT: bold"> set their values back to the DOM</span><br /></li><li>You <span style="TEXT-DECORATION: line-through">piece together these XML fragments to </span><span style="FONT-WEIGHT: bold; TEXT-DECORATION: line-through">create DOM</span><span style="TEXT-DECORATION: line-through"> and</span> <span style="FONT-WEIGHT: bold">save the DOM</span> as the file (overwrite the original file) </li></ol><br /></p>

<p><a href="http://www.flickr.com/photos/choonkeat/16182854/" title="Photo Sharing"><img src="http://photos13.flickr.com/16182854_3d18b47f17_o.jpg" width="512" height="339" alt="760_method2" /></a></p>

<p><br />Method #3   Model (XPath DOM)<br /><br /><ol><li>Read XML from file, and <span style="FONT-WEIGHT: bold">instantiate a DOM</span> object. </li><li><span style="FONT-WEIGHT: bold">Parse the DOM</span>, look for specific elements (e.g.&lt;circle /&gt;, &lt;square /&gt;) and <span style="FONT-WEIGHT: bold">instantiate your corresponding objects</span> for them (e.g. new SquareObject, new CircleObject) <span style="TEXT-DECORATION: line-through">and copy the values from XML to your object (e.g. SquareObject.x = Square.getAttribute(&quot;x&quot;))</span> </li><li>Parse until you finish all elements in your DOM, and you now have a handful of model objects in memory. </li><li><span style="FONT-WEIGHT: bold; TEXT-DECORATION: line-through">Remove the DOM</span><span style="TEXT-DECORATION: line-through"> from memory</span>. </li><li>Now your Graphical Editor <span style="FONT-WEIGHT: bold">application manipulate your Model objects</span> based on the user s inputs.. Draw a line.. Paint as red.. etc </li><li>User choose to save<span style="TEXT-DECORATION: line-through">, you get your Model objects to spit XML back to you</span>, </li><li>You <span style="TEXT-DECORATION: line-through">piece together these XML fragments to create DOM and</span> <span style="FONT-WEIGHT: bold">save the DOM</span> as the file (overwrite the original file) </li></ol></p>

<p><a href="http://www.flickr.com/photos/choonkeat/16182855/" title="Photo Sharing"><img src="http://photos13.flickr.com/16182855_7afb6b788b_o.jpg" width="537" height="341" alt="760_method3" /></a></p>

<p><br />Method #4 - DOM only<br /><br /><ol><li>Read XML from file, and <span style="FONT-WEIGHT: bold">instantiate a DOM</span> object. </li><li style="TEXT-DECORATION: line-through">Parse the DOM, look for specific elements (e.g.&lt;circle /&gt;, &lt;square /&gt;) and instantiate your corresponding objects for them (e.g. new SquareObject, new CircleObject) and copy the values from XML to your object (e.g. SquareObject.x = Square.getAttribute(&quot;x&quot;)) </li><li style="TEXT-DECORATION: line-through">Parse until you finish all elements in your DOM, and you now have a handful of model objects in memory. </li><li><span style="TEXT-DECORATION: line-through">Remove the DOM from memory</span>. </li><li>Now your Graphical Editor <span style="FONT-WEIGHT: bold">application manipulate your </span><span style="TEXT-DECORATION: line-through">Model</span> <span style="FONT-WEIGHT: bold">DOM object</span> based on the user s inputs.. Draw a line.. Paint as red.. etc </li><li>User choose to save<span style="TEXT-DECORATION: line-through">, you get your Model objects to spit XML back to you</span>, </li><li>You <span style="TEXT-DECORATION: line-through">piece together these XML fragments to create DOM and</span> <span style="FONT-WEIGHT: bold">save the DOM</span> as the file (overwrite the original file) </li></ol><p></p>

<p><a href="http://www.flickr.com/photos/choonkeat/16182856/" title="Photo Sharing"><img src="http://photos12.flickr.com/16182856_4552708fec_o.jpg" width="370" height="261" alt="760_method4" /></a></p>

<p><br /><strong>The Analysis</strong><br /><br /><strong>Method#4:</strong> You don't have to be an expert and will be able to tell by the strike-out that Method #4 seems most straight-forward. The only thing is, Step5 (manipulate the DOM) directly in your interface layer just won't cut. That'll be doing classic <a href="http://www.rubyonrails.com/">XML situps</a>. So this is out - unless your editor requires blazing speeeeeed.</p><p><strong>Method#1:</strong> This seem the most common that I've seen. On the hindsight, its surprising to be common. The bad about this design is that values are copied to-and-fro the XML itself. This poses some problems in flexibility in development. You'll need to have <strong>ALL</strong> of the Model classes written and working properly before you can even open-edit-save your first document (Step#7 collects all fragments into 1 XML, missing models == missing fragments == invalid XML). </p><p>If you're writing your own Microsoft Word editor (<a href="http://rep.oio.dk/Microsoft.com/officeschemas/welcome.htm">WordML-based</a>), nobody can ever open-edit-save their Word document until you've 100% finished with your code - if they try before you've done that Model class for less-common features like &quot;themes&quot;.. they'll get rubbish XML file that Microsoft Word can't open anymore. Your XML file isn't correct. Misses out on an attribute. Misses out on that Element. Render their data to trash - what's a worse nightmare for beta testers? So you say, To Hell with the testers! &quot;<a href="http://www.joelonsoftware.com/articles/fog0000000036.html">and we'll ship when we're good and ready</a>&quot; ! This ultimately mean: no early feedback, no rapid application design, no iterative releases, no early adopters, no extreme programming. ZIP.</p><p>Don't care about those things? Say after 3 months and you'd sold a million copies. You think about adding this spiffy feature to blink text will sell another million. You change the XML format of your document, update your Model classes and releases V1.1. Will everyone upgrade? No. Tom uses V1.1 creates blinky text, saves, sends to friend with V1.0, opens no blinky text, edits typo, saves, sends back to Tom, open, no more blinky text. Tom asks you &quot;WTF?&quot;</p><p>For a moment, drop all arguments of &quot;other people's application also like that&quot; and listen to me: If you can get Tom to see his blinky text - for negligible development effort - why not? Now bring back your &quot;other people&quot; argument - you now have an application that handles backward compatibility like non-other. So if you agree with me that Method#1 is A Bad Thing (yes, you agree), we'll proceed with alternatives..</p><p><strong>Method #2:</strong> To solve the bad of Method #1 (losing unimplemented data), we can keep the original document intact. Upon saving the models objects copy their values back to the DOM and the DOM saves itself. Only the modified portions are modified and everyone is happy. Yay! Yay? No. The only reason anyone would do this, is because they <em>feel</em> too much work has been done using Method #1, they've realised the bad too late and this is simply a work-around.</p><p><strong>Method #3:</strong> The models in this design doesn't hold the values at all. When you getXXX() or setXXX(), the Model objects locate the precise spot in the DOM (using Xpath) and get or set <strong>the values in the DOM directly</strong>. So it doesn't suffer from the bad of Method #1. Your model objects are now just Proxies, or Helpers. You'll only need 1 x XPath-based super class to do your XML sit-ups (trust me, with XPath.. XML ain't situps), creating the individual Models subsequently are just a matter of defining the relative paths (String) in each Model. There isn't any XML to do after the super-class.</p><p>Models performing XPath at runtime to get/set values too slow? You can always implement some form of caching there. Remember, writing the models are just specifying strings of paths. No more XML loops, nodes, get text element, hasAttribute.. all these are done by XPath engine and your base class. Development time hastens, users can open-edit-save using your application once you have some of the Models done. If you'd complete the common Models required by your users, they'll be happily using your app whilst you slowly finish off with those unless-but-there features.</p><p><strong>Conclusion</strong><br /><br />So, amuse me. Why not Method #3. </p><p>PS: Don't give me edge what-if-scenarios and say Method #3 can't handle this - Heck! I never said its silver bullet - if other methods can't handle them too, drop it.<br /></p></p>
