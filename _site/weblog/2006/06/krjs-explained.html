<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>KRJS Explained | The Devel!</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="KRJS Explained" />
<meta name="author" content="choonkeat" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Regarding KRJS, I&#39;ve been asked &quot;Hmm.. so you moved the javascript to the controller... what&#39;s the benefit?&quot;. I&#39;ll try to briefly illustrate the benefits here with some Rails/RJS code - the codes in this example are broken, bugs or simply wrong but that&#39;s not the point - hopefully you&#39;ll get the drift.The Problem: Given a textfield and a blank div in Rails, let&#39;s do a google suggest-ish feature&lt;%= text_field_tag &#39;query&#39; %&gt; &lt;div id=&quot;placeholder&quot;&gt;&lt;/div&gt;Method #11. observe your textfield with javascript: &lt;script&gt;&nbsp; // every 3 seconds, check changes typed into textfield &nbsp; my_observer(&#39;query&#39;, 3, &#39;my_call_to_server&#39;); &nbsp; // when called, sends server a request and updates HTML with&nbsp; // response data &nbsp; function my_call_to_server(query) {&nbsp;&nbsp;&nbsp; data = Ajax.get(&quot;http://host:port/my_script?query=&quot; + query);&nbsp;&nbsp;&nbsp; getElementById(&#39;placeholder&#39;).innerHtml = data; &nbsp; }&lt;/script&gt; But let&#39;s be fair, with Rails can cut it down and even get cross-browser compatibility:&lt;%= observe_field(&#39;query&#39;,&nbsp; { :url =&gt; { :action =&gt; &#39; my_script&#39;}, &nbsp; :frequency =&gt; 3, &nbsp; :with =&gt;&#39;query&#39;,&nbsp; :update =&gt; &#39; placeholder&#39;)%&gt;2. Next, handle the Ajax.get on server and spits out HTML. def my_script&nbsp; search_results&nbsp; = search_for(params[&#39;query&#39;]) &nbsp; render text: =&gt; search_results.to_html endNotice the bold portions, these will come back to haunt you when you have many ajax pages - because you&#39;re forced to tie up the whole logic (observe &#39;query&#39; every 3 seconds, send to server &#39;my_script&#39;, update &#39;placeholder&#39;) all inside the HTML template. Dang! These will haunt you when you need to change or add logic (I&#39;m sure you&#39;ve experienced it before) Method #21. Again, observe your textfield (notice the omitted :update option) &lt;%=observe_field(&#39;query &#39;,&nbsp; { :url =&gt; { :action =&gt; &#39;my_script &#39;}, &nbsp; :frequency =&gt; 3,&nbsp; :with =&gt;&#39; query&#39;)%&gt;2. Handle the Ajax.get on server and use RJS to spit out JS (calling page will execute): def my_script&nbsp; search_results&nbsp; = search_for(params[&#39;query&#39;]) &nbsp; render update do |page| &nbsp;&nbsp;&nbsp; page.replace_html :placeholder, search_results.to_html&nbsp;&nbsp;&nbsp; # 2 new whiz-bang features! &nbsp;&nbsp;&nbsp; page.replace_html :title, &quot;Suggestions for #{params[&#39;query&#39;]}&quot; &nbsp;&nbsp;&nbsp; page.hide :advertisement_div if &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; User.find(@session[:user_id]).name == &#39;George&#39; &nbsp; endendNotice lesser amount of bold portions in the template? No more hard coding to update &#39;placeholder&#39;, we&#39;re saying it only at the server side. In fact, its so easy to add more / change JS events with RJS, that I had easily added 2 extra features without any the template changes! To introduce / change features in method #1, you would have to modify the html template. Now, notice that last extra feature... It roughly means &quot;Find current user in database, if the name is George, send an extra javascript event to hide the advertisement div &quot;. Imagine the code you have to juggle if we&#39;re doing this on client side (method #1)!!Method #3NOW.. Let&#39;s have fun with KRJS1. 2. Handle the Ajax.get on server and use RJS to spit out JS (calling page will execute): def on_query_change_3&nbsp; # same code as method #2... endHey! There&#39;s no Step 1(tm). And step 2 is identical to method #2 (all benefits of RJS) except that our function has a specific naming convention. Absolutely no need to touch your template at all! The necessary javascripts in the HTML are inserted automatically when the template is rendered. Let&#39;s say we decide to change the JS event to onblur instead of observing every 3 seconds... come, think what has to be done if we&#39;re using method #1 or #2? Ready? Change 1 file? 2 files? remove observe_field method, and replace with onblur event?... In KRJS, you simply rename your controller handler:def on_query_blur &nbsp; # same code as method #2... end Now, its not really performant right now... the time-savings is mostly conceptual as well as on the development time. The exact implementation could be evolved, no issue: detect external on_xxx.rjs files instead of clogging the controller with on_xxx methods&nbsp;different behavior when in production moderake task to compile for production (faster to render) With KRJS, I can see lots of code-cutting with the many RJS examples out there. Patches are welcome.&nbsp;" />
<meta property="og:description" content="Regarding KRJS, I&#39;ve been asked &quot;Hmm.. so you moved the javascript to the controller... what&#39;s the benefit?&quot;. I&#39;ll try to briefly illustrate the benefits here with some Rails/RJS code - the codes in this example are broken, bugs or simply wrong but that&#39;s not the point - hopefully you&#39;ll get the drift.The Problem: Given a textfield and a blank div in Rails, let&#39;s do a google suggest-ish feature&lt;%= text_field_tag &#39;query&#39; %&gt; &lt;div id=&quot;placeholder&quot;&gt;&lt;/div&gt;Method #11. observe your textfield with javascript: &lt;script&gt;&nbsp; // every 3 seconds, check changes typed into textfield &nbsp; my_observer(&#39;query&#39;, 3, &#39;my_call_to_server&#39;); &nbsp; // when called, sends server a request and updates HTML with&nbsp; // response data &nbsp; function my_call_to_server(query) {&nbsp;&nbsp;&nbsp; data = Ajax.get(&quot;http://host:port/my_script?query=&quot; + query);&nbsp;&nbsp;&nbsp; getElementById(&#39;placeholder&#39;).innerHtml = data; &nbsp; }&lt;/script&gt; But let&#39;s be fair, with Rails can cut it down and even get cross-browser compatibility:&lt;%= observe_field(&#39;query&#39;,&nbsp; { :url =&gt; { :action =&gt; &#39; my_script&#39;}, &nbsp; :frequency =&gt; 3, &nbsp; :with =&gt;&#39;query&#39;,&nbsp; :update =&gt; &#39; placeholder&#39;)%&gt;2. Next, handle the Ajax.get on server and spits out HTML. def my_script&nbsp; search_results&nbsp; = search_for(params[&#39;query&#39;]) &nbsp; render text: =&gt; search_results.to_html endNotice the bold portions, these will come back to haunt you when you have many ajax pages - because you&#39;re forced to tie up the whole logic (observe &#39;query&#39; every 3 seconds, send to server &#39;my_script&#39;, update &#39;placeholder&#39;) all inside the HTML template. Dang! These will haunt you when you need to change or add logic (I&#39;m sure you&#39;ve experienced it before) Method #21. Again, observe your textfield (notice the omitted :update option) &lt;%=observe_field(&#39;query &#39;,&nbsp; { :url =&gt; { :action =&gt; &#39;my_script &#39;}, &nbsp; :frequency =&gt; 3,&nbsp; :with =&gt;&#39; query&#39;)%&gt;2. Handle the Ajax.get on server and use RJS to spit out JS (calling page will execute): def my_script&nbsp; search_results&nbsp; = search_for(params[&#39;query&#39;]) &nbsp; render update do |page| &nbsp;&nbsp;&nbsp; page.replace_html :placeholder, search_results.to_html&nbsp;&nbsp;&nbsp; # 2 new whiz-bang features! &nbsp;&nbsp;&nbsp; page.replace_html :title, &quot;Suggestions for #{params[&#39;query&#39;]}&quot; &nbsp;&nbsp;&nbsp; page.hide :advertisement_div if &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; User.find(@session[:user_id]).name == &#39;George&#39; &nbsp; endendNotice lesser amount of bold portions in the template? No more hard coding to update &#39;placeholder&#39;, we&#39;re saying it only at the server side. In fact, its so easy to add more / change JS events with RJS, that I had easily added 2 extra features without any the template changes! To introduce / change features in method #1, you would have to modify the html template. Now, notice that last extra feature... It roughly means &quot;Find current user in database, if the name is George, send an extra javascript event to hide the advertisement div &quot;. Imagine the code you have to juggle if we&#39;re doing this on client side (method #1)!!Method #3NOW.. Let&#39;s have fun with KRJS1. 2. Handle the Ajax.get on server and use RJS to spit out JS (calling page will execute): def on_query_change_3&nbsp; # same code as method #2... endHey! There&#39;s no Step 1(tm). And step 2 is identical to method #2 (all benefits of RJS) except that our function has a specific naming convention. Absolutely no need to touch your template at all! The necessary javascripts in the HTML are inserted automatically when the template is rendered. Let&#39;s say we decide to change the JS event to onblur instead of observing every 3 seconds... come, think what has to be done if we&#39;re using method #1 or #2? Ready? Change 1 file? 2 files? remove observe_field method, and replace with onblur event?... In KRJS, you simply rename your controller handler:def on_query_blur &nbsp; # same code as method #2... end Now, its not really performant right now... the time-savings is mostly conceptual as well as on the development time. The exact implementation could be evolved, no issue: detect external on_xxx.rjs files instead of clogging the controller with on_xxx methods&nbsp;different behavior when in production moderake task to compile for production (faster to render) With KRJS, I can see lots of code-cutting with the many RJS examples out there. Patches are welcome.&nbsp;" />
<link rel="canonical" href="http://localhost:4000/weblog/2006/06/krjs-explained.html" />
<meta property="og:url" content="http://localhost:4000/weblog/2006/06/krjs-explained.html" />
<meta property="og:site_name" content="The Devel!" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2006-06-25T00:00:00+08:00" />
<script type="application/ld+json">
{"headline":"KRJS Explained","dateModified":"2006-06-25T00:00:00+08:00","datePublished":"2006-06-25T00:00:00+08:00","author":{"@type":"Person","name":"choonkeat"},"description":"Regarding KRJS, I&#39;ve been asked &quot;Hmm.. so you moved the javascript to the controller... what&#39;s the benefit?&quot;. I&#39;ll try to briefly illustrate the benefits here with some Rails/RJS code - the codes in this example are broken, bugs or simply wrong but that&#39;s not the point - hopefully you&#39;ll get the drift.The Problem: Given a textfield and a blank div in Rails, let&#39;s do a google suggest-ish feature&lt;%= text_field_tag &#39;query&#39; %&gt; &lt;div id=&quot;placeholder&quot;&gt;&lt;/div&gt;Method #11. observe your textfield with javascript: &lt;script&gt;&nbsp; // every 3 seconds, check changes typed into textfield &nbsp; my_observer(&#39;query&#39;, 3, &#39;my_call_to_server&#39;); &nbsp; // when called, sends server a request and updates HTML with&nbsp; // response data &nbsp; function my_call_to_server(query) {&nbsp;&nbsp;&nbsp; data = Ajax.get(&quot;http://host:port/my_script?query=&quot; + query);&nbsp;&nbsp;&nbsp; getElementById(&#39;placeholder&#39;).innerHtml = data; &nbsp; }&lt;/script&gt; But let&#39;s be fair, with Rails can cut it down and even get cross-browser compatibility:&lt;%= observe_field(&#39;query&#39;,&nbsp; { :url =&gt; { :action =&gt; &#39; my_script&#39;}, &nbsp; :frequency =&gt; 3, &nbsp; :with =&gt;&#39;query&#39;,&nbsp; :update =&gt; &#39; placeholder&#39;)%&gt;2. Next, handle the Ajax.get on server and spits out HTML. def my_script&nbsp; search_results&nbsp; = search_for(params[&#39;query&#39;]) &nbsp; render text: =&gt; search_results.to_html endNotice the bold portions, these will come back to haunt you when you have many ajax pages - because you&#39;re forced to tie up the whole logic (observe &#39;query&#39; every 3 seconds, send to server &#39;my_script&#39;, update &#39;placeholder&#39;) all inside the HTML template. Dang! These will haunt you when you need to change or add logic (I&#39;m sure you&#39;ve experienced it before) Method #21. Again, observe your textfield (notice the omitted :update option) &lt;%=observe_field(&#39;query &#39;,&nbsp; { :url =&gt; { :action =&gt; &#39;my_script &#39;}, &nbsp; :frequency =&gt; 3,&nbsp; :with =&gt;&#39; query&#39;)%&gt;2. Handle the Ajax.get on server and use RJS to spit out JS (calling page will execute): def my_script&nbsp; search_results&nbsp; = search_for(params[&#39;query&#39;]) &nbsp; render update do |page| &nbsp;&nbsp;&nbsp; page.replace_html :placeholder, search_results.to_html&nbsp;&nbsp;&nbsp; # 2 new whiz-bang features! &nbsp;&nbsp;&nbsp; page.replace_html :title, &quot;Suggestions for #{params[&#39;query&#39;]}&quot; &nbsp;&nbsp;&nbsp; page.hide :advertisement_div if &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; User.find(@session[:user_id]).name == &#39;George&#39; &nbsp; endendNotice lesser amount of bold portions in the template? No more hard coding to update &#39;placeholder&#39;, we&#39;re saying it only at the server side. In fact, its so easy to add more / change JS events with RJS, that I had easily added 2 extra features without any the template changes! To introduce / change features in method #1, you would have to modify the html template. Now, notice that last extra feature... It roughly means &quot;Find current user in database, if the name is George, send an extra javascript event to hide the advertisement div &quot;. Imagine the code you have to juggle if we&#39;re doing this on client side (method #1)!!Method #3NOW.. Let&#39;s have fun with KRJS1. 2. Handle the Ajax.get on server and use RJS to spit out JS (calling page will execute): def on_query_change_3&nbsp; # same code as method #2... endHey! There&#39;s no Step 1(tm). And step 2 is identical to method #2 (all benefits of RJS) except that our function has a specific naming convention. Absolutely no need to touch your template at all! The necessary javascripts in the HTML are inserted automatically when the template is rendered. Let&#39;s say we decide to change the JS event to onblur instead of observing every 3 seconds... come, think what has to be done if we&#39;re using method #1 or #2? Ready? Change 1 file? 2 files? remove observe_field method, and replace with onblur event?... In KRJS, you simply rename your controller handler:def on_query_blur &nbsp; # same code as method #2... end Now, its not really performant right now... the time-savings is mostly conceptual as well as on the development time. The exact implementation could be evolved, no issue: detect external on_xxx.rjs files instead of clogging the controller with on_xxx methods&nbsp;different behavior when in production moderake task to compile for production (faster to render) With KRJS, I can see lots of code-cutting with the many RJS examples out there. Patches are welcome.&nbsp;","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/weblog/2006/06/krjs-explained.html"},"url":"http://localhost:4000/weblog/2006/06/krjs-explained.html","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="The Devel!" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">The Devel!</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">KRJS Explained</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2006-06-25T00:00:00+08:00" itemprop="datePublished">Jun 25, 2006
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Regarding KRJS, I've been asked &quot;Hmm.. so you moved the javascript to the controller... what's the benefit?&quot;. I'll try to briefly illustrate the benefits here with some Rails/RJS code - <strong>the codes in this example are broken, bugs or simply wrong</strong> but that's not the point - hopefully you'll get the drift.<br /><br /><span style="font-weight: bold">The Problem:</span> Given a textfield and a blank div in Rails, let's do a <a target="_blank" onclick="return top.js.OpenExtLink(window,event,this)" href="http://www.google.com/webhp?complete=1"><span style="font-style: italic">google suggest-ish</span> </a> feature<br /><span style="font-family: courier new,monospace">&lt;%= text_field_tag '<span style="font-weight: bold">query</span>' %&gt;</span><br /><span style="font-family: courier new,monospace"> &lt;div id=&quot;<span style="font-weight: bold">placeholder</span>&quot;&gt;&lt;/div&gt;</span><br /><br /><font size="3"><strong>Method #1</strong></font><br />1. observe your textfield with javascript:<br /><span style="font-family: courier new,monospace"> &lt;script&gt;</span><br /><span style="font-family: courier new,monospace">&nbsp; // every 3 seconds, check changes typed into textfield</span><br /> <span style="font-family: courier new,monospace">&nbsp; my_observer('query', 3, 'my_call_to_server');</span><br /><br /><span style="font-family: courier new,monospace"> &nbsp; // when called, sends server a request and updates HTML with</span><br /><span style="font-family: courier new,monospace">&nbsp; // response data</span><br /> <span style="font-family: courier new,monospace">&nbsp; function my_call_to_server(query) {</span><br /><span style="font-family: courier new,monospace">&nbsp;&nbsp;&nbsp; data = Ajax.get(&quot;http://host:port/my_script?query=&quot; + query);</span><br /><span style="font-family: courier new,monospace">&nbsp;&nbsp;&nbsp; getElementById('placeholder').innerHtml = data;</span><br /> <span style="font-family: courier new,monospace">&nbsp; }</span><br /><span style="font-family: courier new,monospace">&lt;/script&gt;</span><br /> <br />But let's be fair, with Rails can cut it down and even get cross-browser compatibility:<br /><span style="font-family: courier new,monospace">&lt;%=</span><br /><span style="font-family: courier new,monospace"> observe_field('<span style="font-weight: bold">query</span>',</span><br /><span style="font-family: courier new,monospace">&nbsp; { :url =&gt; { :action =&gt; '<span style="font-weight: bold"> my_script</span>'}, </span><br /><span style="font-family: courier new,monospace">&nbsp; :frequency =&gt; <span style="font-weight: bold">3</span>,</span><br /> <span style="font-family: courier new,monospace">&nbsp; :with =&gt;'<span style="font-weight: bold">query</span>',</span><br /><span style="font-family: courier new,monospace">&nbsp; :update =&gt; ' <span style="font-weight: bold">placeholder</span>')</span><br /><span style="font-family: courier new,monospace">%&gt;</span><br /><br />2. Next, handle the Ajax.get on server and spits out HTML. <br /><span style="font-family: courier new,monospace">def my_script</span><br /><span style="font-family: courier new,monospace">&nbsp; search_results&nbsp; = search_for(params['query'])</span> <br /><span style="font-family: courier new,monospace">&nbsp; render text: =&gt; search_results.to_html</span><br /><span style="font-family: courier new,monospace"> end</span><br /><br />Notice the bold portions, these will come back to haunt you when you have many ajax pages - because you're forced to tie up the whole logic (observe '<span style="font-weight: bold">query</span>' every  <span style="font-weight: bold">3</span> seconds, send to server '<span style="font-weight: bold">my_script</span>', update '<span style="font-weight: bold">placeholder</span>') all inside the HTML template. Dang! These will haunt you when you need to change or add logic (I'm sure you've experienced it before) <br /><br /><font size="3"><strong>Method #2</strong></font><br />1. Again, observe your textfield (notice the omitted <span style="font-family: courier new,monospace">:update</span> option)<br /><span style="font-family: courier new,monospace"> &lt;%=</span><br /><span style="font-family: courier new,monospace">observe_field('</span><span style="font-weight: bold; font-family: courier new,monospace">query</span><span style="font-family: courier new,monospace"> ',</span><br /><span style="font-family: courier new,monospace">&nbsp; { :url =&gt; { :action =&gt; '</span><span style="font-weight: bold; font-family: courier new,monospace">my_script </span><span style="font-family: courier new,monospace">'}, </span><br /><span style="font-family: courier new,monospace">&nbsp; :frequency =&gt; </span><span style="font-weight: bold; font-family: courier new,monospace"> 3</span><span style="font-family: courier new,monospace">,</span><br /><span style="font-family: courier new,monospace">&nbsp; :with =&gt;'</span><span style="font-weight: bold; font-family: courier new,monospace"> query</span><span style="font-family: courier new,monospace">')</span><br /><span style="font-family: courier new,monospace">%&gt;</span><br /><br />2. Handle the Ajax.get on server and use RJS to spit out JS (calling page will execute): <br /><span style="font-family: courier new,monospace">def my_script</span><br /><span style="font-family: courier new,monospace">&nbsp; search_results&nbsp; = search_for(params['query'])</span> <br /><span style="font-family: courier new,monospace">&nbsp; render update do |page|</span><br /><span style="font-family: courier new,monospace"> &nbsp;&nbsp;&nbsp; page.replace_html :placeholder, search_results.to_html</span><br /><span style="font-family: courier new,monospace"><br /><span style="font-style: italic">&nbsp;&nbsp;&nbsp; # 2 new whiz-bang features! </span></span><br /><span style="font-family: courier new,monospace; font-style: italic">&nbsp;&nbsp;&nbsp; page.replace_html :title, &quot;Suggestions for #{params['query']}&quot; </span><br /><span style="font-family: courier new,monospace; font-style: italic">&nbsp;&nbsp;&nbsp; </span><span style="font-family: courier new,monospace; font-style: italic"> </span><span style="font-family: courier new,monospace; font-style: italic">page.hide :advertisement_div </span><span style="font-family: courier new,monospace; font-style: italic">if <br /><span style="font-style: italic"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>User.find(@session[:user_id]).name == 'George'</span><span style="font-family: courier new,monospace; font-style: italic"><br /></span><span style="font-family: courier new,monospace"> &nbsp; end</span><br /><span style="font-family: courier new,monospace">end</span><br /><br />Notice lesser amount of bold portions in the template? No more hard coding to update 'placeholder', we're saying it only at the server side. In fact, its so easy to add more / change JS events with RJS, that I had easily added 2 extra features without any the template changes! To introduce / change features in method #1, you would have to modify the html template. <br /><br />Now, notice that last extra feature... It roughly means &quot;<span style="font-style: italic">Find current user in database, if the name is George, send an extra javascript event to hide the advertisement div</span> &quot;. Imagine the code you have to juggle if we're doing this on client side (method #1)!!<br /><br /><font size="3"><strong>Method #3</strong></font><br />NOW.. Let's have fun with KRJS<br />1. <br />2. Handle the Ajax.get on server and use RJS to spit out JS (calling page will execute): <br /><span style="font-family: courier new,monospace">def <span style="font-weight: bold">on_query_change_3</span></span><br /><span style="font-family: courier new,monospace">&nbsp;  </span><span style="font-family: courier new,monospace"># same code as method #2...</span><br /><span style="font-family: courier new,monospace"> end</span><br /><br /><span style="font-style: italic">Hey! There's no Step 1(tm)</span>. And step 2 is identical to method #2 (all benefits of RJS) except that our function has a specific naming convention. Absolutely no need to touch your template at all! The necessary javascripts in the HTML are inserted automatically when the template is rendered. <br /><br />Let's say we decide to change the JS event to <span style="font-family: courier new,monospace">onblur</span> instead of observing every 3 seconds... come, think what has to be done if we're using method #1 or #2? Ready? Change 1 file? 2 files? remove observe_field method, and replace with onblur event?... <br /><br />In KRJS, you simply rename your controller handler:<br /><span style="font-family: courier new,monospace">def <span style="font-weight: bold">on_query_blur</span></span><br /> <span style="font-family: courier new,monospace">&nbsp; </span><span style="font-family: courier new,monospace"># same code as method #2...</span><br /> <span style="font-family: courier new,monospace">end</span></p><p>Now, its not really performant right now... the time-savings is mostly conceptual as well as on the development time. The exact implementation could be evolved, no issue:</p><ul><li>detect external on_xxx.rjs files instead of clogging the controller with on_xxx methods&nbsp;</li><li>different behavior when in production mode</li><li>rake task to compile for production (faster to render)</li></ul><p>With KRJS, I can see lots of code-cutting with the many <a href="http://weblog.rubyonrails.org/2006/6/13/new-from-oreilly-rjs-templates-for-rails">RJS examples</a> out there. <a href="http://choonkeat.svnrepository.com/svn/rails-plugins/krjs/">Patches are welcome</a>.&nbsp;</p>


  </div><a class="u-url" href="/weblog/2006/06/krjs-explained.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">The Devel!</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">choonkeat</li><li><a class="u-email" href="mailto:contactme@choonkeat.com">contactme@choonkeat.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/choonkeat"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">choonkeat</span></a></li><li><a href="https://www.twitter.com/choonkeat"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">choonkeat</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>choonkeat on programming &amp; software</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
