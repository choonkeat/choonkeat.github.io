<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>“CRUD! CRUD! CRUD!”: DHH | The Devel!</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="“CRUD! CRUD! CRUD!”: DHH" />
<meta name="author" content="choonkeat" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Well, ok he didn&#39;t exactly do a Steve-Balmer-jumping-around-the-stage thing. But what he was driving at this evening&#39;s keynote is extremely liberating: What if every controller does only* CRUD (create, read, update, destroy)? (Note: DHH understands that only CRUD is just an ideal and its perfectly necessary to drop out of that when needed. Much like how ActiveRecord optimises to support its ideal, yet allows find_by_sql) CRUD is simple and well understood. It is even the only 4 operations baked into the SQL to manipulating data - INSERT, SELECT, UPDATE, DELETE. So if 80% of the web apps are simply database-backed web applications, asking controllers to just revolve around CRUD isn&#39;t that demanding is it? Using HTTP GET, POST, PUT and DELETE. Instead of, POST /people/destroy/1 it now becomes, DELETE /people/1&nbsp; Note: Though technical concerns are valid, it doesn&#39;t sound like David is looking for protocol purity. Workarounds are acceptable if that&#39;s what&#39;s required to make this work. Having CRUD-only conventions means not needing to decide method names anymore - this is one of those stupid small things that nibbles at you like deciding the names of foreign keys. Say you have a &quot;Student&quot; controller, but you&#39;re adding a &quot;Subject&quot; to him? Hmm... StudentController#take_subject() or SubjectController#add_student()? Is it so simple as associating the 2 models? Are there other operations that needs to be done when such association is created or destroyed? (eh? crud verbs sneaking in...) Before you know it... your StudentController would have 4 methods that arguably relates more to Subjects: drop_subject, show_subjects, update_subjects. In a CRUD-only world, since controllers are preferred to operate with CRUD-only constraint - and neither Student&#39;s nor Subject&#39;s CRUD should handle that - let&#39;s create a StudyController instead. Now, operations on this student-subject relation will occur simply as CRUD operations in the StudyController. Makes everything equally simple and awfully consistent. Then he builds on top of &quot;if its a CRUD-only world anyways&quot; and introduces the concept that had just hit him a few days ago: Active Resources. Basically, resources which can be operated upon, behind the scenes, via RESTful CRUD URLs. And of cos, with Rails-style conventions, you KNOW it will be easy. Note: The idea is just to model web resources, not to abstract away the underlying engine (sql or url?) for a single model object. To quote his reply (roughly), &quot;I don&#39;t believe in just flipping a switch and swapping the underlying technology... These things will leak.&quot;. When I saw the slides, I got a flashback to a 2005 Adam Bosworth speech: MySQL, don&#39;t scale like Oracle! Think bigger! If truely scalable data store is what Adam Bosworth has described (and GData is apparently Google’s implementation of such infrastructure) then Rails is well on its way. Taking big strides towards it (knowingly or not) while most other frameworks are still grappling over composite primary keys and plural table names controversies.  &lt;p&gt;Rails 1.2 is going to be very, very interesting. &lt;/p&gt; &lt;p&gt;Note: Shucks.. KRJS naming convention needs a new home then? &lt;/p&gt;" />
<meta property="og:description" content="Well, ok he didn&#39;t exactly do a Steve-Balmer-jumping-around-the-stage thing. But what he was driving at this evening&#39;s keynote is extremely liberating: What if every controller does only* CRUD (create, read, update, destroy)? (Note: DHH understands that only CRUD is just an ideal and its perfectly necessary to drop out of that when needed. Much like how ActiveRecord optimises to support its ideal, yet allows find_by_sql) CRUD is simple and well understood. It is even the only 4 operations baked into the SQL to manipulating data - INSERT, SELECT, UPDATE, DELETE. So if 80% of the web apps are simply database-backed web applications, asking controllers to just revolve around CRUD isn&#39;t that demanding is it? Using HTTP GET, POST, PUT and DELETE. Instead of, POST /people/destroy/1 it now becomes, DELETE /people/1&nbsp; Note: Though technical concerns are valid, it doesn&#39;t sound like David is looking for protocol purity. Workarounds are acceptable if that&#39;s what&#39;s required to make this work. Having CRUD-only conventions means not needing to decide method names anymore - this is one of those stupid small things that nibbles at you like deciding the names of foreign keys. Say you have a &quot;Student&quot; controller, but you&#39;re adding a &quot;Subject&quot; to him? Hmm... StudentController#take_subject() or SubjectController#add_student()? Is it so simple as associating the 2 models? Are there other operations that needs to be done when such association is created or destroyed? (eh? crud verbs sneaking in...) Before you know it... your StudentController would have 4 methods that arguably relates more to Subjects: drop_subject, show_subjects, update_subjects. In a CRUD-only world, since controllers are preferred to operate with CRUD-only constraint - and neither Student&#39;s nor Subject&#39;s CRUD should handle that - let&#39;s create a StudyController instead. Now, operations on this student-subject relation will occur simply as CRUD operations in the StudyController. Makes everything equally simple and awfully consistent. Then he builds on top of &quot;if its a CRUD-only world anyways&quot; and introduces the concept that had just hit him a few days ago: Active Resources. Basically, resources which can be operated upon, behind the scenes, via RESTful CRUD URLs. And of cos, with Rails-style conventions, you KNOW it will be easy. Note: The idea is just to model web resources, not to abstract away the underlying engine (sql or url?) for a single model object. To quote his reply (roughly), &quot;I don&#39;t believe in just flipping a switch and swapping the underlying technology... These things will leak.&quot;. When I saw the slides, I got a flashback to a 2005 Adam Bosworth speech: MySQL, don&#39;t scale like Oracle! Think bigger! If truely scalable data store is what Adam Bosworth has described (and GData is apparently Google’s implementation of such infrastructure) then Rails is well on its way. Taking big strides towards it (knowingly or not) while most other frameworks are still grappling over composite primary keys and plural table names controversies.  &lt;p&gt;Rails 1.2 is going to be very, very interesting. &lt;/p&gt; &lt;p&gt;Note: Shucks.. KRJS naming convention needs a new home then? &lt;/p&gt;" />
<link rel="canonical" href="http://localhost:4000/weblog/2006/06/crud-crud-crud.html" />
<meta property="og:url" content="http://localhost:4000/weblog/2006/06/crud-crud-crud.html" />
<meta property="og:site_name" content="The Devel!" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2006-06-25T00:00:00+08:00" />
<script type="application/ld+json">
{"headline":"“CRUD! CRUD! CRUD!”: DHH","dateModified":"2006-06-25T00:00:00+08:00","datePublished":"2006-06-25T00:00:00+08:00","author":{"@type":"Person","name":"choonkeat"},"description":"Well, ok he didn&#39;t exactly do a Steve-Balmer-jumping-around-the-stage thing. But what he was driving at this evening&#39;s keynote is extremely liberating: What if every controller does only* CRUD (create, read, update, destroy)? (Note: DHH understands that only CRUD is just an ideal and its perfectly necessary to drop out of that when needed. Much like how ActiveRecord optimises to support its ideal, yet allows find_by_sql) CRUD is simple and well understood. It is even the only 4 operations baked into the SQL to manipulating data - INSERT, SELECT, UPDATE, DELETE. So if 80% of the web apps are simply database-backed web applications, asking controllers to just revolve around CRUD isn&#39;t that demanding is it? Using HTTP GET, POST, PUT and DELETE. Instead of, POST /people/destroy/1 it now becomes, DELETE /people/1&nbsp; Note: Though technical concerns are valid, it doesn&#39;t sound like David is looking for protocol purity. Workarounds are acceptable if that&#39;s what&#39;s required to make this work. Having CRUD-only conventions means not needing to decide method names anymore - this is one of those stupid small things that nibbles at you like deciding the names of foreign keys. Say you have a &quot;Student&quot; controller, but you&#39;re adding a &quot;Subject&quot; to him? Hmm... StudentController#take_subject() or SubjectController#add_student()? Is it so simple as associating the 2 models? Are there other operations that needs to be done when such association is created or destroyed? (eh? crud verbs sneaking in...) Before you know it... your StudentController would have 4 methods that arguably relates more to Subjects: drop_subject, show_subjects, update_subjects. In a CRUD-only world, since controllers are preferred to operate with CRUD-only constraint - and neither Student&#39;s nor Subject&#39;s CRUD should handle that - let&#39;s create a StudyController instead. Now, operations on this student-subject relation will occur simply as CRUD operations in the StudyController. Makes everything equally simple and awfully consistent. Then he builds on top of &quot;if its a CRUD-only world anyways&quot; and introduces the concept that had just hit him a few days ago: Active Resources. Basically, resources which can be operated upon, behind the scenes, via RESTful CRUD URLs. And of cos, with Rails-style conventions, you KNOW it will be easy. Note: The idea is just to model web resources, not to abstract away the underlying engine (sql or url?) for a single model object. To quote his reply (roughly), &quot;I don&#39;t believe in just flipping a switch and swapping the underlying technology... These things will leak.&quot;. When I saw the slides, I got a flashback to a 2005 Adam Bosworth speech: MySQL, don&#39;t scale like Oracle! Think bigger! If truely scalable data store is what Adam Bosworth has described (and GData is apparently Google’s implementation of such infrastructure) then Rails is well on its way. Taking big strides towards it (knowingly or not) while most other frameworks are still grappling over composite primary keys and plural table names controversies.  &lt;p&gt;Rails 1.2 is going to be very, very interesting. &lt;/p&gt; &lt;p&gt;Note: Shucks.. KRJS naming convention needs a new home then? &lt;/p&gt;","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/weblog/2006/06/crud-crud-crud.html"},"url":"http://localhost:4000/weblog/2006/06/crud-crud-crud.html","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="The Devel!" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">The Devel!</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">&quot;CRUD! CRUD! CRUD!&quot;: DHH</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2006-06-25T00:00:00+08:00" itemprop="datePublished">Jun 25, 2006
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Well, ok he didn't exactly do a Steve-Balmer-jumping-around-the-stage thing. But what he was driving at this evening's keynote is extremely liberating: </p> <p><em>What if every controller does only* CRUD  (create, read, update, destroy)?</em></p> <p>(Note: DHH understands that only CRUD is just an ideal and its perfectly necessary to drop out of that when needed. Much like how ActiveRecord optimises to support its ideal, yet allows find_by_sql) </p> <p>CRUD is simple and well understood. It is even the only 4 operations baked into the SQL to manipulating data - INSERT, SELECT, UPDATE, DELETE. So if 80% of the web apps are simply database-backed web applications, asking controllers to just revolve around CRUD isn't that demanding is it? <a href="http://www.loudthinking.com/arc/000572.html">Using HTTP GET, POST, PUT and DELETE.</a> Instead of, </p> <pre>POST /people/destroy/1 </pre> <p>it now becomes, </p> <pre>DELETE /people/1&nbsp;</pre> <p>Note: Though <a href="http://www.intertwingly.net/blog/2006/03/12/HTTP-Best-Practices">technical concerns</a> are valid, it doesn't sound like David is looking for protocol purity. Workarounds are acceptable if that's what's required to make this work.<br /> </p> <p>Having CRUD-only conventions means not needing to decide method names anymore - this is one of those stupid small things that nibbles at you like deciding the names of foreign keys. Say you have a &quot;Student&quot; controller, but you're adding a &quot;Subject&quot; to him? Hmm... StudentController#take_subject() or SubjectController#add_student()? Is it so simple as associating the 2 models? Are there other operations that needs to be done when such association is created or destroyed? (eh? crud verbs sneaking in...) Before you know it... your StudentController would have 4 methods that arguably relates more to Subjects: drop_subject, show_subjects, update_subjects. <br /> </p> <p>In a CRUD-only world, since controllers are preferred to operate with CRUD-only constraint - and neither Student's nor Subject's CRUD should handle that - let's create a StudyController instead. Now, operations on this student-subject relation will occur simply as CRUD operations in the StudyController.  Makes everything equally simple and awfully consistent.</p> <p>Then he builds on top of &quot;<em>if its a CRUD-only world anyways</em>&quot; and introduces the concept that had just hit him <a href="http://www.loudthinking.com/arc/000592.html">a few days ago</a>: Active Resources. Basically, resources which can be operated upon, behind the scenes, via RESTful CRUD URLs. And of cos, with Rails-style conventions, you <em>KNOW</em> it will be easy. </p><p>Note: The idea is just to model web resources, not to abstract away the underlying engine (sql or url?) for a single model object. To quote his reply (roughly), &quot;<em>I don't believe in just flipping a switch and swapping the underlying technology... These things will leak.</em>&quot;. </p><p>When I saw the slides, I got a flashback to a 2005 Adam Bosworth speech: <a href="http://www.itconversations.com/shows/detail571.html">MySQL, don't scale like Oracle! Think bigger!<br /></a></p>If truely scalable data store is what Adam Bosworth has described (and <a href="http://code.google.com/apis/gdata/">GData</a> is apparently Google's implementation of such infrastructure) then Rails is well on its way. Taking big strides towards it (knowingly or not) while most other frameworks are still grappling over composite primary keys and plural table names controversies.&nbsp; <p>Rails 1.2 is going to be very, very interesting.&nbsp;</p> <p>Note: Shucks.. <a href="http://choonkeat.svnrepository.com/svn/rails-plugins/krjs/">KRJS</a> naming convention needs a new home then?<br /> </p>


  </div><a class="u-url" href="/weblog/2006/06/crud-crud-crud.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">The Devel!</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">choonkeat</li><li><a class="u-email" href="mailto:contactme@choonkeat.com">contactme@choonkeat.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/choonkeat"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">choonkeat</span></a></li><li><a href="https://www.twitter.com/choonkeat"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">choonkeat</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>choonkeat on programming &amp; software</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
