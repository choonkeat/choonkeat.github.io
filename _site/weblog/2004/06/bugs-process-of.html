<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Bugs. Process of Testing | The Devel!</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="Bugs. Process of Testing" />
<meta name="author" content="choonkeat" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Fiddling with bugzilla just now.. and was contemplating on creating a button for our QA team to click on (instead of going to Bugzilla&#39;s enter bug directly)This button will trigger a process toPlace a unique stamp on logGenerates a URL (to view the log at the stamp, and -500 lines before it)Redirects to bugzilla&#39;s enter new bug page, with the URL pre-filled into the bug description field.Kewl.. this would be awfully useful to the developer receiving the bug.. Rather than trying to replicate the error and looking at the logs he&#39;d generated for answers.. the developer might as well visit the log of the original incident directly..But... Not all bugs would potentially have useful hints in the logs ya?.. what if the log rotates dammit.. my viewer has to cater to that - dammit.. my viewer/stamper would be deployment specific.. and also, while I&#39;m at saving the developer&#39;s time (avoid having to repeat the steps described)... I might as well save the QA&#39;s time in describing his steps in the first place?I mean, the QA is using a computer ya? A computer knows and can record everything that goes through it, ya? Why not have aMiddle-layer sniffer to capture all to-fro traffic.. and a viewer counterpart that is able to (guess-timate) reproduce each originating (form fields prefilled)/resultant HTML page.. (how about javascripts on forms?)QA-specific-browser that records the buttons clicked, etc.. (how about browser compatibility?)QA-tool that wraps any browser to collect data.. (big engineering effort? how about playback?)Plugins to browsers to collect such data and counterpart plugins to playback such data?The QA&#39;s steps would thus be reduced toClick &#39;Start Test Case&#39;Go about doing his thing,.. and some error occursClick &#39;Report Bug&#39; Go back to Step #1 to proceed with other thingsAll the back-end Bugzilla-like stuffs of opening bug, issue tracking, logging, recording steps, notifying developer could be automated at Step #3.. I&#39;m not seasoned in the field of testing.. I haven&#39;t even tried *gasp* JUnit.. and I&#39;m not sure if a company like Mercury Interactive would&#39;ve already had something like that.. But I would believe I can use something like that." />
<meta property="og:description" content="Fiddling with bugzilla just now.. and was contemplating on creating a button for our QA team to click on (instead of going to Bugzilla&#39;s enter bug directly)This button will trigger a process toPlace a unique stamp on logGenerates a URL (to view the log at the stamp, and -500 lines before it)Redirects to bugzilla&#39;s enter new bug page, with the URL pre-filled into the bug description field.Kewl.. this would be awfully useful to the developer receiving the bug.. Rather than trying to replicate the error and looking at the logs he&#39;d generated for answers.. the developer might as well visit the log of the original incident directly..But... Not all bugs would potentially have useful hints in the logs ya?.. what if the log rotates dammit.. my viewer has to cater to that - dammit.. my viewer/stamper would be deployment specific.. and also, while I&#39;m at saving the developer&#39;s time (avoid having to repeat the steps described)... I might as well save the QA&#39;s time in describing his steps in the first place?I mean, the QA is using a computer ya? A computer knows and can record everything that goes through it, ya? Why not have aMiddle-layer sniffer to capture all to-fro traffic.. and a viewer counterpart that is able to (guess-timate) reproduce each originating (form fields prefilled)/resultant HTML page.. (how about javascripts on forms?)QA-specific-browser that records the buttons clicked, etc.. (how about browser compatibility?)QA-tool that wraps any browser to collect data.. (big engineering effort? how about playback?)Plugins to browsers to collect such data and counterpart plugins to playback such data?The QA&#39;s steps would thus be reduced toClick &#39;Start Test Case&#39;Go about doing his thing,.. and some error occursClick &#39;Report Bug&#39; Go back to Step #1 to proceed with other thingsAll the back-end Bugzilla-like stuffs of opening bug, issue tracking, logging, recording steps, notifying developer could be automated at Step #3.. I&#39;m not seasoned in the field of testing.. I haven&#39;t even tried *gasp* JUnit.. and I&#39;m not sure if a company like Mercury Interactive would&#39;ve already had something like that.. But I would believe I can use something like that." />
<link rel="canonical" href="http://localhost:4000/weblog/2004/06/bugs-process-of.html" />
<meta property="og:url" content="http://localhost:4000/weblog/2004/06/bugs-process-of.html" />
<meta property="og:site_name" content="The Devel!" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2004-06-13T00:00:00+08:00" />
<script type="application/ld+json">
{"headline":"Bugs. Process of Testing","dateModified":"2004-06-13T00:00:00+08:00","datePublished":"2004-06-13T00:00:00+08:00","author":{"@type":"Person","name":"choonkeat"},"description":"Fiddling with bugzilla just now.. and was contemplating on creating a button for our QA team to click on (instead of going to Bugzilla&#39;s enter bug directly)This button will trigger a process toPlace a unique stamp on logGenerates a URL (to view the log at the stamp, and -500 lines before it)Redirects to bugzilla&#39;s enter new bug page, with the URL pre-filled into the bug description field.Kewl.. this would be awfully useful to the developer receiving the bug.. Rather than trying to replicate the error and looking at the logs he&#39;d generated for answers.. the developer might as well visit the log of the original incident directly..But... Not all bugs would potentially have useful hints in the logs ya?.. what if the log rotates dammit.. my viewer has to cater to that - dammit.. my viewer/stamper would be deployment specific.. and also, while I&#39;m at saving the developer&#39;s time (avoid having to repeat the steps described)... I might as well save the QA&#39;s time in describing his steps in the first place?I mean, the QA is using a computer ya? A computer knows and can record everything that goes through it, ya? Why not have aMiddle-layer sniffer to capture all to-fro traffic.. and a viewer counterpart that is able to (guess-timate) reproduce each originating (form fields prefilled)/resultant HTML page.. (how about javascripts on forms?)QA-specific-browser that records the buttons clicked, etc.. (how about browser compatibility?)QA-tool that wraps any browser to collect data.. (big engineering effort? how about playback?)Plugins to browsers to collect such data and counterpart plugins to playback such data?The QA&#39;s steps would thus be reduced toClick &#39;Start Test Case&#39;Go about doing his thing,.. and some error occursClick &#39;Report Bug&#39; Go back to Step #1 to proceed with other thingsAll the back-end Bugzilla-like stuffs of opening bug, issue tracking, logging, recording steps, notifying developer could be automated at Step #3.. I&#39;m not seasoned in the field of testing.. I haven&#39;t even tried *gasp* JUnit.. and I&#39;m not sure if a company like Mercury Interactive would&#39;ve already had something like that.. But I would believe I can use something like that.","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/weblog/2004/06/bugs-process-of.html"},"url":"http://localhost:4000/weblog/2004/06/bugs-process-of.html","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="The Devel!" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">The Devel!</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Bugs. Process of Testing</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2004-06-13T00:00:00+08:00" itemprop="datePublished">Jun 13, 2004
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p> Fiddling with bugzilla just now.. and was contemplating on creating a button for our QA team to click on (instead of going to Bugzilla's enter bug directly)<br /><br />This button will trigger a process to<br /><br /><ol><li>Place a unique stamp on log</li><li>Generates a URL (to view the log at the stamp, and -500 lines before it)</li><li>Redirects to bugzilla's enter new bug page, with the URL pre-filled into the bug description field.</li></ol>Kewl.. this would be awfully useful to the developer receiving the bug.. Rather than trying to replicate the error and looking at the logs he'd <i>generated </i>for answers.. the developer might as well visit the log of the <i>original </i>incident directly..<br /><br />But...<br /><br /> Not all bugs would potentially have useful hints in the logs ya?.. what if the log rotates dammit.. my viewer has to cater to that - dammit.. my viewer/stamper would be deployment specific.. and also, while I'm at saving the developer's time (avoid having to repeat the steps described)... I might as well save the QA's time in describing his steps in the first place?<br /><br />I mean, the QA is using a computer ya? A computer knows and can record everything that goes through it, ya? Why not have a<br /><ol><li>Middle-layer sniffer to capture all to-fro traffic.. and a viewer counterpart that is able to (guess-timate) reproduce each originating (form fields prefilled)/resultant HTML page.. (how about javascripts on forms?)<br /></li><li>QA-specific-browser that records the buttons clicked, etc..  (how about browser compatibility?)</li><li>QA-tool that wraps any browser to collect data.. (big engineering effort? how about playback?)<br /></li><li>Plugins to browsers to collect such data and counterpart plugins to playback such data?</li></ol>The QA's steps would thus be reduced to<br /><ol><li>Click 'Start Test Case'</li><li>Go about doing his thing,.. and some error occurs<br /></li><li>Click 'Report Bug' <br /></li><li>Go back to Step #1 to proceed with other things<br /></li></ol>All the back-end Bugzilla-like stuffs of opening bug, issue tracking, logging, recording steps, notifying developer could be automated at Step #3.. I'm not seasoned in the field of testing.. I haven't even tried *gasp* JUnit.. and I'm not sure if a company like Mercury Interactive would've already had something like that.. <br /><br />But I would believe I can use something like that.<br /></p>


  </div><a class="u-url" href="/weblog/2004/06/bugs-process-of.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">The Devel!</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">choonkeat</li><li><a class="u-email" href="mailto:contactme@choonkeat.com">contactme@choonkeat.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/choonkeat"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">choonkeat</span></a></li><li><a href="https://www.twitter.com/choonkeat"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">choonkeat</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>choonkeat on programming &amp; software</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
