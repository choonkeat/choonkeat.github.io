<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>i18n.. aka Internationalisation | The Devel!</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="i18n.. aka Internationalisation" />
<meta name="author" content="choonkeat" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I&#39;m mainly involved in Java programming, hence the ResourceBundle is synonymous to i18n. Its a good framework at runtime (when the program is running).. but one&#39;s gotta admit is a very expensive process at codetime (when writing the program). Its a pain to introduce the map languages, strings, keys for the sake of &quot;multi-lingual support should the product ever go into the China/India/(insert your favourite country) market&quot;.. GUI IDE (integrated development environment) only takes 1 step closer by helping you with GUI tables for managing the i18n text.. but its still a very painful process.Luckily there is a better way!&lt;/insert /&gt;Why not do i18n as a post-thought. i.e. Write applications like they&#39;re only for your native language (that&#39;s how everyone intuitively does it anyways).. and only add i18n support when you need to the product to do so. It can be a pretty GUI ant-task that parses the source code, looks for static strings (for HTML codes, any text that is not embraced within angled brackets) and checks with the user how the string should be i18n. The user-experience to run such a post-production process would greatly mirror those doing a spell checker in Word (-gasp- i&#39;m quoting MS again.. i must be defecting) The i18n-checker goes through the source and resources, and prompts for replacements.. it should handle things like:- &quot;Apply changes to all&quot; to not ask the same things again.. or a select from list of translations for easy re-usability.- Support placing of arguments, e.g. &quot;Hello, {0}&quot; and &quot;{0}, &#20320;&#22909;&quot;, in a intuitive manner- Support multi-pass parsing. i.e. the user may not have the time to sit and translate the whole source tree in 1-pass. Subsequent patches to the code should be parsable without re-parsing the old portions.I think its very do-able (at least in the preliminary).. by looking for static text and changing them into ResourceBundle calls (after prompting for user input).. Doing i18n in any other way, IMHO, is simply a waste of the developers&#39; man-hours." />
<meta property="og:description" content="I&#39;m mainly involved in Java programming, hence the ResourceBundle is synonymous to i18n. Its a good framework at runtime (when the program is running).. but one&#39;s gotta admit is a very expensive process at codetime (when writing the program). Its a pain to introduce the map languages, strings, keys for the sake of &quot;multi-lingual support should the product ever go into the China/India/(insert your favourite country) market&quot;.. GUI IDE (integrated development environment) only takes 1 step closer by helping you with GUI tables for managing the i18n text.. but its still a very painful process.Luckily there is a better way!&lt;/insert /&gt;Why not do i18n as a post-thought. i.e. Write applications like they&#39;re only for your native language (that&#39;s how everyone intuitively does it anyways).. and only add i18n support when you need to the product to do so. It can be a pretty GUI ant-task that parses the source code, looks for static strings (for HTML codes, any text that is not embraced within angled brackets) and checks with the user how the string should be i18n. The user-experience to run such a post-production process would greatly mirror those doing a spell checker in Word (-gasp- i&#39;m quoting MS again.. i must be defecting) The i18n-checker goes through the source and resources, and prompts for replacements.. it should handle things like:- &quot;Apply changes to all&quot; to not ask the same things again.. or a select from list of translations for easy re-usability.- Support placing of arguments, e.g. &quot;Hello, {0}&quot; and &quot;{0}, &#20320;&#22909;&quot;, in a intuitive manner- Support multi-pass parsing. i.e. the user may not have the time to sit and translate the whole source tree in 1-pass. Subsequent patches to the code should be parsable without re-parsing the old portions.I think its very do-able (at least in the preliminary).. by looking for static text and changing them into ResourceBundle calls (after prompting for user input).. Doing i18n in any other way, IMHO, is simply a waste of the developers&#39; man-hours." />
<link rel="canonical" href="http://localhost:4000/weblog/2004/05/i18n-aka-intern.html" />
<meta property="og:url" content="http://localhost:4000/weblog/2004/05/i18n-aka-intern.html" />
<meta property="og:site_name" content="The Devel!" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2004-05-11T00:00:00+08:00" />
<script type="application/ld+json">
{"headline":"i18n.. aka Internationalisation","dateModified":"2004-05-11T00:00:00+08:00","datePublished":"2004-05-11T00:00:00+08:00","author":{"@type":"Person","name":"choonkeat"},"description":"I&#39;m mainly involved in Java programming, hence the ResourceBundle is synonymous to i18n. Its a good framework at runtime (when the program is running).. but one&#39;s gotta admit is a very expensive process at codetime (when writing the program). Its a pain to introduce the map languages, strings, keys for the sake of &quot;multi-lingual support should the product ever go into the China/India/(insert your favourite country) market&quot;.. GUI IDE (integrated development environment) only takes 1 step closer by helping you with GUI tables for managing the i18n text.. but its still a very painful process.Luckily there is a better way!&lt;/insert /&gt;Why not do i18n as a post-thought. i.e. Write applications like they&#39;re only for your native language (that&#39;s how everyone intuitively does it anyways).. and only add i18n support when you need to the product to do so. It can be a pretty GUI ant-task that parses the source code, looks for static strings (for HTML codes, any text that is not embraced within angled brackets) and checks with the user how the string should be i18n. The user-experience to run such a post-production process would greatly mirror those doing a spell checker in Word (-gasp- i&#39;m quoting MS again.. i must be defecting) The i18n-checker goes through the source and resources, and prompts for replacements.. it should handle things like:- &quot;Apply changes to all&quot; to not ask the same things again.. or a select from list of translations for easy re-usability.- Support placing of arguments, e.g. &quot;Hello, {0}&quot; and &quot;{0}, &#20320;&#22909;&quot;, in a intuitive manner- Support multi-pass parsing. i.e. the user may not have the time to sit and translate the whole source tree in 1-pass. Subsequent patches to the code should be parsable without re-parsing the old portions.I think its very do-able (at least in the preliminary).. by looking for static text and changing them into ResourceBundle calls (after prompting for user input).. Doing i18n in any other way, IMHO, is simply a waste of the developers&#39; man-hours.","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/weblog/2004/05/i18n-aka-intern.html"},"url":"http://localhost:4000/weblog/2004/05/i18n-aka-intern.html","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="The Devel!" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">The Devel!</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">i18n.. aka Internationalisation</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2004-05-11T00:00:00+08:00" itemprop="datePublished">May 11, 2004
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>I'm mainly involved in Java programming, hence the ResourceBundle is synonymous to i18n. Its a good framework at runtime (when the program is running).. but one's gotta admit is a very expensive process at codetime (when writing the program). Its a pain to introduce the map languages, strings, keys for the sake of &quot;multi-lingual support should the product ever go into the China/India/<insert country="" your="" />(insert your favourite country) market&quot;.. <br /><br />GUI IDE (integrated development environment) only takes 1 step closer by helping you with GUI tables for managing the i18n text.. but its still a very painful process.<br /><br />Luckily there is a better way!<br /><br /></insert />Why not do i18n as a post-thought. i.e. Write applications like they're only for your native language (that's how everyone intuitively does it anyways).. and only add i18n support when you need to the product to do so. It can be a pretty GUI ant-task that parses the source code, looks for static strings (for HTML codes, any text that is not embraced within angled brackets) and checks with the user how the string should be i18n. The user-experience to run such a post-production process would greatly mirror those doing a spell checker in Word (-gasp- i'm quoting MS again.. i must be defecting) The i18n-checker goes through the source and resources, and prompts for replacements.. it should handle things like:<br /><br />- &quot;Apply changes to all&quot; to not ask the same things again.. or a select from list of translations for easy re-usability.<br />- Support placing of arguments, e.g. &quot;Hello, {0}&quot; and &quot;{0}, &#20320;&#22909;&quot;, in a intuitive manner<br />- Support multi-pass parsing. i.e. the user may not have the time to sit and translate the whole source tree in 1-pass. Subsequent patches to the code should be parsable without re-parsing the old portions.<br /><br />I think its very do-able (at least in the preliminary).. by looking for static text and changing them into ResourceBundle calls (after prompting for user input).. <br /><br />Doing i18n in any other way, IMHO, is simply a waste of the developers' man-hours.<br /></p>


  </div><a class="u-url" href="/weblog/2004/05/i18n-aka-intern.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">The Devel!</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">choonkeat</li><li><a class="u-email" href="mailto:contactme@choonkeat.com">contactme@choonkeat.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/choonkeat"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">choonkeat</span></a></li><li><a href="https://www.twitter.com/choonkeat"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">choonkeat</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>choonkeat on programming &amp; software</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
